DECLARE
    v_count  INT;
    v_name VARCHAR2(20);
    TYPE namesarray IS VARRAY(15) OF VARCHAR2(20);
    names    namesarray;
BEGIN
    names := namesarray('author', 'country', 'genre', 'permissions', 'series', 'status', 'book',
                        'book_author', 'book_genre', 'book_instance', 'book_instance_history', 'users');

    FOR i IN 1..names.count LOOP
        v_name := names(i);

        SELECT COUNT(*) INTO v_count FROM user_tables WHERE table_name = upper(v_name);
        IF v_count = 1 THEN
            DBMS_OUTPUT.PUT_LINE('Dropping table: ' || v_name);
            EXECUTE IMMEDIATE 'DROP TABLE '|| v_name || ' CASCADE CONSTRAINTS';
        END IF;
    END LOOP;
END;

/


CREATE TABLE author (
    author_id  NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY INCREMENT BY 1 START WITH 1 MAXVALUE 999999 CONSTRAINT author_pk PRIMARY KEY,
    first_name VARCHAR2(50 BYTE) NOT NULL,
    last_name  VARCHAR2(255 BYTE) NOT NULL,
    birth_year NUMBER NOT NULL,
    death_year NUMBER,
    biography  LONG,
    photo      VARCHAR2(255 BYTE) DEFAULT 'anonim.jpg'
);

CREATE TABLE country (
    country_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT country_pk PRIMARY KEY,
    name       VARCHAR2(255 BYTE) NOT NULL,
)

CREATE TABLE genre (
    genre_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT genre_pk PRIMARY KEY,
    name     VARCHAR2(50 BYTE) NOT NULL,
)

CREATE TABLE permissions (
    permission_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 NOT NULL CONSTRAINT permission_id PRIMARY KEY,
    name          VARCHAR2(40 CHAR) NOT NULL,
)

CREATE TABLE series (
    series_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT series_pk PRIMARY KEY,
    name      VARCHAR2(255 BYTE) NOT NULL,
)

CREATE TABLE status (
    status_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT status_pk PRIMARY KEY,
    name      VARCHAR2(255 BYTE) NOT NULL,
)

CREATE TABLE book (
    book_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY INCREMENT BY 1 START WITH 1 MAXVALUE 999999 CONSTRAINT book_pk PRIMARY KEY,
    title            VARCHAR2(255 BYTE) NOT NULL,
    summary          LONG NOT NULL,
    publication_year NUMBER NOT NULL,
    pages            NUMBER NOT NULL,
    cover            VARCHAR2(255 BYTE) DEFAULT 'unknown_cover.png',
    country_id       NUMBER NOT NULL REFERENCES country ( country_id ),
    series_id        NUMBER REFERENCES series ( series_id ),
    language_id      NUMBER NOT NULL REFERENCES language ( language_id ),
    date_added       DATE DEFAULT sysdate
);

CREATE TABLE book_author (
    book_id   NUMBER NOT NULL REFERENCES book ( book_id ),
    author_id NUMBER NOT NULL REFERENCES author ( author_id ),
    CONSTRAINT book_author_pk PRIMARY KEY ( book_id, author_id )
)

CREATE TABLE book_genre (
    genre_id NUMBER NOT NULL REFERENCES genre ( genre_id ),
    book_id  NUMBER NOT NULL REFERENCES book ( book_id ),
    CONSTRAINT book_genre_pk PRIMARY KEY ( genre_id, book_id )
)

CREATE TABLE book_instance (
    book_instance_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT book_instance_pk PRIMARY KEY,
    book_id          NUMBER NOT NULL REFERENCES book ( book_id ),
    user_id          NUMBER REFERENCES users ( user_id ),
    status_id        NUMBER DEFAULT 0 REFERENCES status ( status_id ),
)

CREATE TABLE book_instance_history (
    bih_id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT book_instance_history_pk PRIMARY KEY,
    book_instance_id NUMBER NOT NULL,
    user_id          NUMBER NOT NULL,
    borrow_date      DATE NOT NULL,
    return_date      DATE,
)

CREATE TABLE users (
    user_id       NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 CONSTRAINT user_pk PRIMARY KEY,
    name          VARCHAR2(40 CHAR) NOT NULL,
    surname       VARCHAR2(40 CHAR) NOT NULL,
    login         VARCHAR2(40 CHAR) NOT NULL UNIQUE,
    password      VARCHAR2(98 CHAR) NOT NULL,
    permission_id NUMBER DEFAULT 2 REFERENCES users ( user_id ),
)



CREATE OR REPLACE FUNCTION format_text(p_text VARCHAR2)
RETURN VARCHAR2
AS
    v_lower_cased VARCHAR2(255);
    v_firts_letter VARCHAR2(255);
    v_result VARCHAR2(255);
BEGIN
    SELECT LOWER(p_text) INTO v_lower_cased FROM dual;
    SELECT SUBSTR(v_lower_cased, 0, 1) INTO v_firts_letter FROM dual;
    SELECT CONCAT(UPPER(v_firts_letter), SUBSTR(v_lower_cased, 2)) INTO v_result FROM dual;
    RETURN v_result;
END;
/

CREATE OR REPLACE FUNCTION procent (p_sid INTEGER)
RETURN NUMBER
AS
v_count_b_s INTEGER;
v_count_b INTEGER;
v_count_p INTEGER;
BEGIN
    SELECT count(book_instance_id) INTO v_count_b
    FROM book_instance;
    
    SELECT count(book_instance_id) INTO v_count_b_s
    FROM book_instance where status_id = p_sid;
    
    v_count_p := v_count_b_s / v_count_b * 100;
    RETURN v_count_p;
END;
/

CREATE OR REPLACE PROCEDURE add_book(p_title VARCHAR2, p_summary VARCHAR2, p_publication_year NUMBER, p_pages NUMBER, p_cover_src VARCHAR2, p_country VARCHAR2, p_language VARCHAR2)
AS
    v_country_exists NUMBER;
    v_language_exists NUMBER;
    v_language_id NUMBER;
    v_country_id NUMBER;
BEGIN
    SELECT count(country_id) INTO v_country_exists from country WHERE country.name = p_country;
    IF v_country_exists = 0 THEN
        RAISE no_data_found;
    ELSE
        SELECT country_id INTO v_country_id from country WHERE country.name LIKE p_country;
    END IF;

    SELECT count(language_id) INTO v_language_exists from language WHERE language.name = p_language;
    IF v_language_exists = 0 THEN
        RAISE no_data_found;
    ELSE
        SELECT language_id INTO v_language_id from language WHERE language.name LIKE p_language;
    END IF;

    INSERT INTO book(title, summary, publication_year, pages, cover, country_id, language_id)
        VALUES(p_title, p_summary, p_publication_year, p_pages, p_cover_src, v_country_id, v_language_id);
EXCEPTION
    WHEN no_data_found THEN
        dbms_output.put_line ('Invalid name of country or/and language.');
        RAISE; 
END;
/

CREATE OR REPLACE PROCEDURE lend_book(p_user_id NUMBER, p_book_instance_id NUMBER)
AS
    e_book_in_use EXCEPTION;
    PRAGMA exception_init( e_book_in_use, -20001 );
    e_book_not_reserved EXCEPTION;
    PRAGMA exception_init( e_book_not_reserved, -20002 );
    v_user_id   NUMBER;
    v_status    status.name%TYPE;

BEGIN
    select user_id, s.name
    into v_user_id, v_status
    from book_instance join status s using(status_id)
    where book_instance_id = p_book_instance_id;
    
    if v_user_id <> p_user_id then
        raise e_book_in_use;
    elsif v_status <> 'RESERVED' then
        raise e_book_not_reserved;
    else
        update book_instance set user_id = p_user_id, status_id = 2 where book_instance_id = p_book_instance_id;
    end if;
EXCEPTION
    WHEN e_book_in_use THEN
        dbms_output.put_line ('Book is already in use.');
        RAISE; 
    WHEN e_book_not_reserved THEN
        dbms_output.put_line ('Book is not reserved by this user.');
        RAISE; 
END;
/

CREATE OR REPLACE TRIGGER write_to_history
AFTER UPDATE OF user_id ON book_instance
FOR EACH ROW
WHEN(new.status_id != old.status_id)
DECLARE
    v_curr_date DATE;
    v_lent_id NUMBER;
    v_available_id NUMBER;
BEGIN
    SELECT status.status_id INTO v_lent_id FROM status WHERE name = 'LENT';
    SELECT status.status_id INTO v_available_id FROM status WHERE name = 'AVAILABLE';
    select SYSDATE INTO v_curr_date from dual;

    IF :new.status_id = v_lent_id THEN --lent
        INSERT INTO book_instance_history(book_instance_id, user_id, borrow_date) VALUES(:new.book_instance_id , :new.user_id, v_curr_date);
    ELSIF :new.status_id = v_available_id THEN --returned
        UPDATE book_instance_history
        SET return_date = v_curr_date
        WHERE book_instance_id = :new.book_instance_id;
    END IF;
END write_to_history;
/

CREATE OR REPLACE TRIGGER tg_admins
BEFORE INSERT OR UPDATE of permission_id ON users 
FOR EACH ROW
DECLARE
    e_too_many_admins EXCEPTION;
    PRAGMA exception_init( e_too_many_admins, -20001 );
    v_admin_permission_id NUMBER;
    v_permission_id NUMBER;
    v_count NUMBER;
    c_admins_limit CONSTANT NUMBER:=2;
BEGIN
    SELECT permission_id INTO v_admin_permission_id FROM permissions where name = 'Admin';
    SELECT count(user_id) INTO v_count FROM users WHERE permission_id = v_admin_permission_id;

    IF (v_count >= c_admins_limit AND :new.permission_id = v_admin_permission_id) THEN 
        RAISE e_too_many_admins;
    END IF;
EXCEPTION
    WHEN e_too_many_admins THEN
        dbms_output.put_line ('Too many admins (limit: ' || c_admins_limit || ').');
        RAISE; 

END tg_admins;
/
